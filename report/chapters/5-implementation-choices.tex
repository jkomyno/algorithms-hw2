\section{Scelte implementative}
\label{cap:implementation-choices}

\subsection{Codice templatizzato}

Al fine di rendere il codice quanto più generico ed estendibile, molte delle classi e dei metodi scritti
usano i template C++, corrispondenti ai generics in Java.
I nomi ricorrenti dei tipi generici impiegati sono \codeinline{Label} e \codeinline{Weight}.
\codeinline{Label} denota il tipo del nome di un nodo del grafo. È istanziato come \codeinline{size\_t}, corrispondente a \codeinline{unsigned long long}, occupa almeno 64bit può rappresentare solo valori $\geq 0$.
\codeinline{Weight} denota il tipo del peso di un arco del grafo. È istanziato come \codeinline{long}, corrispondente a \codeinline{signed long int},
occupa almeno 32bit.

\subsection{Rappresentazione del grafo}
\label{sub:graph-representation}

Gli algoritmi di questo homework operano su grafi pesati connessi e non diretti. In questo caso in particolare, ai nodi viene assegnato un intero da 1 a n che lo identifica ed una posizione nel piano che può essere geografico o euclidea a seconda del formato specificato.

\noindent Per rappresentare quindi questa particolare istanza di grafo abbiamo deciso di utilizzare una Matrice di Adiacenza (\textit{Adj. Matrix}), in particolare in questo specifico contesto useremo una \textbf{Matrice delle distanze}: dati due nodi del grafo essa restituisce la distanza dei due nodi a partire dalle coordinate di quest'ultimi. In particolare:
\begin{itemize}
    \item \textbf{Se le coordinate sono in formato EUC\_2D}: significa che esse rappresentano la posizione nel piano euclideo a 2 dimensioni. Viene dunque calcolata la distanza euclidea tra ogni nodo e il risultato viene inserito nella corrispondente posizione della matrice delle distanze.
    \item \textbf{Se le coordinate sono in formato GEO}: significa che esse rappresentano la posizione in termini geografici (ossia latitudine e longitudine). Vengono quindi convertite in radianti e calcolata la distanza con l'apposito codice fornito nella consegna e il risultato viene inserito nella corrispondente posizione della matrice delle distanze.
\end{itemize}

E quindi possibile tramite la matrice delle distanze, rappresentare l'intero grafo in quanto le righe o le colonne rappresentano i nodi del grafo, mentre i valori contenuti in essa rappresentano le distanze tra i nodi considerati. Le coordinate dei nodi vengono perse in quanto non sono necessarie ai fini della risoluzione del problema del TSP.


\subsubsection {Costruzione del Grafo}
La procedura per costruire il grafo, ossia costruire la matrice delle distanze richiede le seguente operazioni:
\begin{enumerate}
    \item Lettura del file di input: in particolare in questa fase vengono estratte tutte le informazioni necessarie, come il tipo di file che si sta leggendo (formato EUC\_2D o GEO) e il numero di nodi presenti; 
    \item Una volta identificato il formato del file, viene letto ogni singolo nodo con le sue coordinate ed inserito in un vettore.
    \item Viene creata la matrice delle distanze, calcolando tutte le distanze di ogni nodo con ogni altro nodo del grafo. La distanza viene calcolata a seconda del formato delle coordinate del file di input.
\end{enumerate}

\paragraph{Ottimizzazioni}\mbox{} \\
\noindent Per definizione, la matrice delle distanze risulta essere una matrice simmetrica con gli elementi della diagonale pari a 0 (in quanto ogni nodo dista 0 da se stesso). Pertanto è possibile calcolare le distanze della matrice triangolare superiore e copiare poi i valori in maniera speculare nella matrice triangolare inferiore, risparmiando così in termini di tempo. E' possibile fare ciò in quanto la distanza tra un nodi i e j e la stessa tra j e i.\\


\subsection{Strutture Dati}

Tutte le strutture dati elencate di seguito sono definite nella cartella \textit{Shared}.
Ove possibile, per la nomenclatura dei metodi abbiamo cercato di seguire lo stesso standard dei container STL di C++.
Inoltre, le strutture dati usate sono sempre pre-allocate in memoria quando possibile, evitando rehashing e riallocazioni dispendiose. Questo significa che la maggior parte delle operazioni indicate con \complexityConstant{} ammortizzato siano in realtà totalmente costanti nella pratica.

\subsubsection{Heap}

\textit{Heap.h} contiene la definizione astratta di una generica Heap.
Gli elementi della Heap sono salvati in un \codeinline{std::vector}.
Per generalizzare il concetto di MinHeap/MaxHeap, la classe usa un comparatore binario booleano. Se il funtore dato in input alla classe è
\codeinline{std::greater<>}, la struttura dati avrà la semantica di una Min Heap; viceversa, con il comparatore \codeinline{std::less<>} si avrà la semantica di una Max Heap.

\paragraph{Ottimizzazioni}\mbox{} \\

\noindent Il parametro template \textit{IsAlreadyHeap} è usato per evitare di costruire la Heap se l'utente specifica che il container dato in input alla struttura dati rispetta già la proprietà di essere una Heap. Il controllo su questo flag booleano avviene a compile-time. Questa ottimizzazione garantisce un risparmio di tempo pari a \complexityN{}, ed è usata nell'implementazione dell'algoritmo di \textbf{Prim}. \\

\noindent I metodi che ripristinano la prioprietà di Heap (\codeinline{heapify\_up} e \codeinline{heapify\_down}) sono definiti in modo iterativo invece che ricorsivo, per eliminare alla radice tutti i problemi di ottimizzazione legati alla ricorsione che questo specifico linguaggio porta con se.

\subsubsection{Binary Heap}

\textit{BinaryHeap.h} contiene una classe concreta che eredita \textit{Heap.h} e ne implementa i metodi virtuali. Definisce una Binary Heap, ovvero è possibile rappresentare gli elementi salvati come un albero binario completo (tranne eventualmente l'ultimo livello, che potrebbe non essere completo) che rispetta la proprietà di ordinamento delle Heap.

\paragraph{Ottimizzazioni}\mbox{} \\

\noindent L'operazione di divisione per 2, utilizzata ad esempio per determinare i figli sinistro e destro di un nodo nella Heap, è stata sostituita con l'operazione di shift binario.

\subsubsection{K-ary Heap}

\textit{KHeap.h} contiene una classe concreta che eredita \textit{Heap.h} e ne implementa i metodi virtuali. Definisce una K-ary Heap, ovvero è possibile rappresentare gli elementi salvati come un albero k-ario completo (tranne eventualmente l'ultimo livello, che potrebbe non essere completo) che rispetta la proprietà di ordinamento delle Heap.
\textit{K} è un parametro template che deve essere strettamente maggiore di due.

\subsubsection{Priority Queue}

\textit{PriorityQueue.h} è una classe concreta che eredita privatamente \textit{BinaryHeap.h} o \textit{KHeap.h}, a seconda del parametro template \textit{Heap}.
La semantica di PriorityQueue dipende dal comparatore passato al costruttore, che indica se si vuole usare una coda di priorità basata su Min Heap o su Max Heap. \\

\noindent PriorityQueue ha accesso diretto ai nodi salvati nella Heap, e usa due container associativi di tipo \codeinline{std::unordered\_map} per tenere traccia delle chiavi e degli indici posizionali di ogni elemento della Heap, permettendone la lettura e l'aggiornamento in tempo costante ammortizzato. \\

\noindent Rispetto ai costruttori delle varie classi Heap, PriorityQueue richiede non un comparatore, bensì una factory di comparatori. A tale factory è data in input una mappa che associa i valori degli elementi della Heap alle rispettive chiavi. Poiché tale input è passato per reference, il comparatore generato userà sempre la versione più aggiornata della mappa.

\noindent L'operazione di aggiornamento di una chiave richiede chiavi strettamente discendenti nel caso di una MinHeap, e chiavi strettamente crescenti nel caso di una MaxHeap. Abbiamo imposto questo vincolo per mantenere la complessità di \codeinline{update\_key} logaritmica anziché lineare (come sarebbe se avessimo usato il metodo \codeinline{build\_heap} indistintamente).

\paragraph{Ottimizzazioni}\mbox{} \\

\noindent Poichè istanziare una PriorityQueue così generica e flessibile è un'operazione non banale, abbiamo creato una serie di funzioni di utilità di facile comprensione da usare. Ad esempio, per creare una coda di priorità basata su una Min Heap binaria, esiste il metodo \codeinline{make\_min\_priority\_queue} (analogamente esiste \codeinline{make\_min\_k\_priority\_queue} per Min Heap K-ary).
L'utente finale della classe non deve preoccuparsi di inserire manualmente tutti i parametri template di tali funzioni, grazie alla \textit{type deduction} di C++17.
